// Code generated by ent, DO NOT EDIT.

package payment

import (
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/naelcodes/ab-backend/ent/predicate"
)

// ID filters vertices based on their ID field.
func ID(id int) predicate.Payment {
	return predicate.Payment(sql.FieldEQ(FieldID, id))
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.Payment {
	return predicate.Payment(sql.FieldEQ(FieldID, id))
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.Payment {
	return predicate.Payment(sql.FieldNEQ(FieldID, id))
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.Payment {
	return predicate.Payment(sql.FieldIn(FieldID, ids...))
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.Payment {
	return predicate.Payment(sql.FieldNotIn(FieldID, ids...))
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.Payment {
	return predicate.Payment(sql.FieldGT(FieldID, id))
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.Payment {
	return predicate.Payment(sql.FieldGTE(FieldID, id))
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.Payment {
	return predicate.Payment(sql.FieldLT(FieldID, id))
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.Payment {
	return predicate.Payment(sql.FieldLTE(FieldID, id))
}

// Number applies equality check predicate on the "number" field. It's identical to NumberEQ.
func Number(v string) predicate.Payment {
	return predicate.Payment(sql.FieldEQ(FieldNumber, v))
}

// Date applies equality check predicate on the "date" field. It's identical to DateEQ.
func Date(v string) predicate.Payment {
	return predicate.Payment(sql.FieldEQ(FieldDate, v))
}

// Balance applies equality check predicate on the "balance" field. It's identical to BalanceEQ.
func Balance(v float64) predicate.Payment {
	vc, err := ValueScanner.Balance.Value(v)
	return predicate.PaymentOrErr(sql.FieldEQ(FieldBalance, vc), err)
}

// Amount applies equality check predicate on the "amount" field. It's identical to AmountEQ.
func Amount(v float64) predicate.Payment {
	vc, err := ValueScanner.Amount.Value(v)
	return predicate.PaymentOrErr(sql.FieldEQ(FieldAmount, vc), err)
}

// BaseAmount applies equality check predicate on the "base_amount" field. It's identical to BaseAmountEQ.
func BaseAmount(v float64) predicate.Payment {
	vc, err := ValueScanner.BaseAmount.Value(v)
	return predicate.PaymentOrErr(sql.FieldEQ(FieldBaseAmount, vc), err)
}

// UsedAmount applies equality check predicate on the "used_amount" field. It's identical to UsedAmountEQ.
func UsedAmount(v float64) predicate.Payment {
	vc, err := ValueScanner.UsedAmount.Value(v)
	return predicate.PaymentOrErr(sql.FieldEQ(FieldUsedAmount, vc), err)
}

// IDChartOfAccounts applies equality check predicate on the "id_chart_of_accounts" field. It's identical to IDChartOfAccountsEQ.
func IDChartOfAccounts(v int) predicate.Payment {
	return predicate.Payment(sql.FieldEQ(FieldIDChartOfAccounts, v))
}

// IDCurrency applies equality check predicate on the "id_currency" field. It's identical to IDCurrencyEQ.
func IDCurrency(v int) predicate.Payment {
	return predicate.Payment(sql.FieldEQ(FieldIDCurrency, v))
}

// NumberEQ applies the EQ predicate on the "number" field.
func NumberEQ(v string) predicate.Payment {
	return predicate.Payment(sql.FieldEQ(FieldNumber, v))
}

// NumberNEQ applies the NEQ predicate on the "number" field.
func NumberNEQ(v string) predicate.Payment {
	return predicate.Payment(sql.FieldNEQ(FieldNumber, v))
}

// NumberIn applies the In predicate on the "number" field.
func NumberIn(vs ...string) predicate.Payment {
	return predicate.Payment(sql.FieldIn(FieldNumber, vs...))
}

// NumberNotIn applies the NotIn predicate on the "number" field.
func NumberNotIn(vs ...string) predicate.Payment {
	return predicate.Payment(sql.FieldNotIn(FieldNumber, vs...))
}

// NumberGT applies the GT predicate on the "number" field.
func NumberGT(v string) predicate.Payment {
	return predicate.Payment(sql.FieldGT(FieldNumber, v))
}

// NumberGTE applies the GTE predicate on the "number" field.
func NumberGTE(v string) predicate.Payment {
	return predicate.Payment(sql.FieldGTE(FieldNumber, v))
}

// NumberLT applies the LT predicate on the "number" field.
func NumberLT(v string) predicate.Payment {
	return predicate.Payment(sql.FieldLT(FieldNumber, v))
}

// NumberLTE applies the LTE predicate on the "number" field.
func NumberLTE(v string) predicate.Payment {
	return predicate.Payment(sql.FieldLTE(FieldNumber, v))
}

// NumberContains applies the Contains predicate on the "number" field.
func NumberContains(v string) predicate.Payment {
	return predicate.Payment(sql.FieldContains(FieldNumber, v))
}

// NumberHasPrefix applies the HasPrefix predicate on the "number" field.
func NumberHasPrefix(v string) predicate.Payment {
	return predicate.Payment(sql.FieldHasPrefix(FieldNumber, v))
}

// NumberHasSuffix applies the HasSuffix predicate on the "number" field.
func NumberHasSuffix(v string) predicate.Payment {
	return predicate.Payment(sql.FieldHasSuffix(FieldNumber, v))
}

// NumberEqualFold applies the EqualFold predicate on the "number" field.
func NumberEqualFold(v string) predicate.Payment {
	return predicate.Payment(sql.FieldEqualFold(FieldNumber, v))
}

// NumberContainsFold applies the ContainsFold predicate on the "number" field.
func NumberContainsFold(v string) predicate.Payment {
	return predicate.Payment(sql.FieldContainsFold(FieldNumber, v))
}

// DateEQ applies the EQ predicate on the "date" field.
func DateEQ(v string) predicate.Payment {
	return predicate.Payment(sql.FieldEQ(FieldDate, v))
}

// DateNEQ applies the NEQ predicate on the "date" field.
func DateNEQ(v string) predicate.Payment {
	return predicate.Payment(sql.FieldNEQ(FieldDate, v))
}

// DateIn applies the In predicate on the "date" field.
func DateIn(vs ...string) predicate.Payment {
	return predicate.Payment(sql.FieldIn(FieldDate, vs...))
}

// DateNotIn applies the NotIn predicate on the "date" field.
func DateNotIn(vs ...string) predicate.Payment {
	return predicate.Payment(sql.FieldNotIn(FieldDate, vs...))
}

// DateGT applies the GT predicate on the "date" field.
func DateGT(v string) predicate.Payment {
	return predicate.Payment(sql.FieldGT(FieldDate, v))
}

// DateGTE applies the GTE predicate on the "date" field.
func DateGTE(v string) predicate.Payment {
	return predicate.Payment(sql.FieldGTE(FieldDate, v))
}

// DateLT applies the LT predicate on the "date" field.
func DateLT(v string) predicate.Payment {
	return predicate.Payment(sql.FieldLT(FieldDate, v))
}

// DateLTE applies the LTE predicate on the "date" field.
func DateLTE(v string) predicate.Payment {
	return predicate.Payment(sql.FieldLTE(FieldDate, v))
}

// DateContains applies the Contains predicate on the "date" field.
func DateContains(v string) predicate.Payment {
	return predicate.Payment(sql.FieldContains(FieldDate, v))
}

// DateHasPrefix applies the HasPrefix predicate on the "date" field.
func DateHasPrefix(v string) predicate.Payment {
	return predicate.Payment(sql.FieldHasPrefix(FieldDate, v))
}

// DateHasSuffix applies the HasSuffix predicate on the "date" field.
func DateHasSuffix(v string) predicate.Payment {
	return predicate.Payment(sql.FieldHasSuffix(FieldDate, v))
}

// DateEqualFold applies the EqualFold predicate on the "date" field.
func DateEqualFold(v string) predicate.Payment {
	return predicate.Payment(sql.FieldEqualFold(FieldDate, v))
}

// DateContainsFold applies the ContainsFold predicate on the "date" field.
func DateContainsFold(v string) predicate.Payment {
	return predicate.Payment(sql.FieldContainsFold(FieldDate, v))
}

// BalanceEQ applies the EQ predicate on the "balance" field.
func BalanceEQ(v float64) predicate.Payment {
	vc, err := ValueScanner.Balance.Value(v)
	return predicate.PaymentOrErr(sql.FieldEQ(FieldBalance, vc), err)
}

// BalanceNEQ applies the NEQ predicate on the "balance" field.
func BalanceNEQ(v float64) predicate.Payment {
	vc, err := ValueScanner.Balance.Value(v)
	return predicate.PaymentOrErr(sql.FieldNEQ(FieldBalance, vc), err)
}

// BalanceIn applies the In predicate on the "balance" field.
func BalanceIn(vs ...float64) predicate.Payment {
	var (
		err error
		v   = make([]any, len(vs))
	)
	for i := range v {
		if v[i], err = ValueScanner.Balance.Value(vs[i]); err != nil {
			break
		}
	}
	return predicate.PaymentOrErr(sql.FieldIn(FieldBalance, v...), err)
}

// BalanceNotIn applies the NotIn predicate on the "balance" field.
func BalanceNotIn(vs ...float64) predicate.Payment {
	var (
		err error
		v   = make([]any, len(vs))
	)
	for i := range v {
		if v[i], err = ValueScanner.Balance.Value(vs[i]); err != nil {
			break
		}
	}
	return predicate.PaymentOrErr(sql.FieldNotIn(FieldBalance, v...), err)
}

// BalanceGT applies the GT predicate on the "balance" field.
func BalanceGT(v float64) predicate.Payment {
	vc, err := ValueScanner.Balance.Value(v)
	return predicate.PaymentOrErr(sql.FieldGT(FieldBalance, vc), err)
}

// BalanceGTE applies the GTE predicate on the "balance" field.
func BalanceGTE(v float64) predicate.Payment {
	vc, err := ValueScanner.Balance.Value(v)
	return predicate.PaymentOrErr(sql.FieldGTE(FieldBalance, vc), err)
}

// BalanceLT applies the LT predicate on the "balance" field.
func BalanceLT(v float64) predicate.Payment {
	vc, err := ValueScanner.Balance.Value(v)
	return predicate.PaymentOrErr(sql.FieldLT(FieldBalance, vc), err)
}

// BalanceLTE applies the LTE predicate on the "balance" field.
func BalanceLTE(v float64) predicate.Payment {
	vc, err := ValueScanner.Balance.Value(v)
	return predicate.PaymentOrErr(sql.FieldLTE(FieldBalance, vc), err)
}

// AmountEQ applies the EQ predicate on the "amount" field.
func AmountEQ(v float64) predicate.Payment {
	vc, err := ValueScanner.Amount.Value(v)
	return predicate.PaymentOrErr(sql.FieldEQ(FieldAmount, vc), err)
}

// AmountNEQ applies the NEQ predicate on the "amount" field.
func AmountNEQ(v float64) predicate.Payment {
	vc, err := ValueScanner.Amount.Value(v)
	return predicate.PaymentOrErr(sql.FieldNEQ(FieldAmount, vc), err)
}

// AmountIn applies the In predicate on the "amount" field.
func AmountIn(vs ...float64) predicate.Payment {
	var (
		err error
		v   = make([]any, len(vs))
	)
	for i := range v {
		if v[i], err = ValueScanner.Amount.Value(vs[i]); err != nil {
			break
		}
	}
	return predicate.PaymentOrErr(sql.FieldIn(FieldAmount, v...), err)
}

// AmountNotIn applies the NotIn predicate on the "amount" field.
func AmountNotIn(vs ...float64) predicate.Payment {
	var (
		err error
		v   = make([]any, len(vs))
	)
	for i := range v {
		if v[i], err = ValueScanner.Amount.Value(vs[i]); err != nil {
			break
		}
	}
	return predicate.PaymentOrErr(sql.FieldNotIn(FieldAmount, v...), err)
}

// AmountGT applies the GT predicate on the "amount" field.
func AmountGT(v float64) predicate.Payment {
	vc, err := ValueScanner.Amount.Value(v)
	return predicate.PaymentOrErr(sql.FieldGT(FieldAmount, vc), err)
}

// AmountGTE applies the GTE predicate on the "amount" field.
func AmountGTE(v float64) predicate.Payment {
	vc, err := ValueScanner.Amount.Value(v)
	return predicate.PaymentOrErr(sql.FieldGTE(FieldAmount, vc), err)
}

// AmountLT applies the LT predicate on the "amount" field.
func AmountLT(v float64) predicate.Payment {
	vc, err := ValueScanner.Amount.Value(v)
	return predicate.PaymentOrErr(sql.FieldLT(FieldAmount, vc), err)
}

// AmountLTE applies the LTE predicate on the "amount" field.
func AmountLTE(v float64) predicate.Payment {
	vc, err := ValueScanner.Amount.Value(v)
	return predicate.PaymentOrErr(sql.FieldLTE(FieldAmount, vc), err)
}

// BaseAmountEQ applies the EQ predicate on the "base_amount" field.
func BaseAmountEQ(v float64) predicate.Payment {
	vc, err := ValueScanner.BaseAmount.Value(v)
	return predicate.PaymentOrErr(sql.FieldEQ(FieldBaseAmount, vc), err)
}

// BaseAmountNEQ applies the NEQ predicate on the "base_amount" field.
func BaseAmountNEQ(v float64) predicate.Payment {
	vc, err := ValueScanner.BaseAmount.Value(v)
	return predicate.PaymentOrErr(sql.FieldNEQ(FieldBaseAmount, vc), err)
}

// BaseAmountIn applies the In predicate on the "base_amount" field.
func BaseAmountIn(vs ...float64) predicate.Payment {
	var (
		err error
		v   = make([]any, len(vs))
	)
	for i := range v {
		if v[i], err = ValueScanner.BaseAmount.Value(vs[i]); err != nil {
			break
		}
	}
	return predicate.PaymentOrErr(sql.FieldIn(FieldBaseAmount, v...), err)
}

// BaseAmountNotIn applies the NotIn predicate on the "base_amount" field.
func BaseAmountNotIn(vs ...float64) predicate.Payment {
	var (
		err error
		v   = make([]any, len(vs))
	)
	for i := range v {
		if v[i], err = ValueScanner.BaseAmount.Value(vs[i]); err != nil {
			break
		}
	}
	return predicate.PaymentOrErr(sql.FieldNotIn(FieldBaseAmount, v...), err)
}

// BaseAmountGT applies the GT predicate on the "base_amount" field.
func BaseAmountGT(v float64) predicate.Payment {
	vc, err := ValueScanner.BaseAmount.Value(v)
	return predicate.PaymentOrErr(sql.FieldGT(FieldBaseAmount, vc), err)
}

// BaseAmountGTE applies the GTE predicate on the "base_amount" field.
func BaseAmountGTE(v float64) predicate.Payment {
	vc, err := ValueScanner.BaseAmount.Value(v)
	return predicate.PaymentOrErr(sql.FieldGTE(FieldBaseAmount, vc), err)
}

// BaseAmountLT applies the LT predicate on the "base_amount" field.
func BaseAmountLT(v float64) predicate.Payment {
	vc, err := ValueScanner.BaseAmount.Value(v)
	return predicate.PaymentOrErr(sql.FieldLT(FieldBaseAmount, vc), err)
}

// BaseAmountLTE applies the LTE predicate on the "base_amount" field.
func BaseAmountLTE(v float64) predicate.Payment {
	vc, err := ValueScanner.BaseAmount.Value(v)
	return predicate.PaymentOrErr(sql.FieldLTE(FieldBaseAmount, vc), err)
}

// UsedAmountEQ applies the EQ predicate on the "used_amount" field.
func UsedAmountEQ(v float64) predicate.Payment {
	vc, err := ValueScanner.UsedAmount.Value(v)
	return predicate.PaymentOrErr(sql.FieldEQ(FieldUsedAmount, vc), err)
}

// UsedAmountNEQ applies the NEQ predicate on the "used_amount" field.
func UsedAmountNEQ(v float64) predicate.Payment {
	vc, err := ValueScanner.UsedAmount.Value(v)
	return predicate.PaymentOrErr(sql.FieldNEQ(FieldUsedAmount, vc), err)
}

// UsedAmountIn applies the In predicate on the "used_amount" field.
func UsedAmountIn(vs ...float64) predicate.Payment {
	var (
		err error
		v   = make([]any, len(vs))
	)
	for i := range v {
		if v[i], err = ValueScanner.UsedAmount.Value(vs[i]); err != nil {
			break
		}
	}
	return predicate.PaymentOrErr(sql.FieldIn(FieldUsedAmount, v...), err)
}

// UsedAmountNotIn applies the NotIn predicate on the "used_amount" field.
func UsedAmountNotIn(vs ...float64) predicate.Payment {
	var (
		err error
		v   = make([]any, len(vs))
	)
	for i := range v {
		if v[i], err = ValueScanner.UsedAmount.Value(vs[i]); err != nil {
			break
		}
	}
	return predicate.PaymentOrErr(sql.FieldNotIn(FieldUsedAmount, v...), err)
}

// UsedAmountGT applies the GT predicate on the "used_amount" field.
func UsedAmountGT(v float64) predicate.Payment {
	vc, err := ValueScanner.UsedAmount.Value(v)
	return predicate.PaymentOrErr(sql.FieldGT(FieldUsedAmount, vc), err)
}

// UsedAmountGTE applies the GTE predicate on the "used_amount" field.
func UsedAmountGTE(v float64) predicate.Payment {
	vc, err := ValueScanner.UsedAmount.Value(v)
	return predicate.PaymentOrErr(sql.FieldGTE(FieldUsedAmount, vc), err)
}

// UsedAmountLT applies the LT predicate on the "used_amount" field.
func UsedAmountLT(v float64) predicate.Payment {
	vc, err := ValueScanner.UsedAmount.Value(v)
	return predicate.PaymentOrErr(sql.FieldLT(FieldUsedAmount, vc), err)
}

// UsedAmountLTE applies the LTE predicate on the "used_amount" field.
func UsedAmountLTE(v float64) predicate.Payment {
	vc, err := ValueScanner.UsedAmount.Value(v)
	return predicate.PaymentOrErr(sql.FieldLTE(FieldUsedAmount, vc), err)
}

// TypeEQ applies the EQ predicate on the "type" field.
func TypeEQ(v Type) predicate.Payment {
	return predicate.Payment(sql.FieldEQ(FieldType, v))
}

// TypeNEQ applies the NEQ predicate on the "type" field.
func TypeNEQ(v Type) predicate.Payment {
	return predicate.Payment(sql.FieldNEQ(FieldType, v))
}

// TypeIn applies the In predicate on the "type" field.
func TypeIn(vs ...Type) predicate.Payment {
	return predicate.Payment(sql.FieldIn(FieldType, vs...))
}

// TypeNotIn applies the NotIn predicate on the "type" field.
func TypeNotIn(vs ...Type) predicate.Payment {
	return predicate.Payment(sql.FieldNotIn(FieldType, vs...))
}

// FopEQ applies the EQ predicate on the "fop" field.
func FopEQ(v Fop) predicate.Payment {
	return predicate.Payment(sql.FieldEQ(FieldFop, v))
}

// FopNEQ applies the NEQ predicate on the "fop" field.
func FopNEQ(v Fop) predicate.Payment {
	return predicate.Payment(sql.FieldNEQ(FieldFop, v))
}

// FopIn applies the In predicate on the "fop" field.
func FopIn(vs ...Fop) predicate.Payment {
	return predicate.Payment(sql.FieldIn(FieldFop, vs...))
}

// FopNotIn applies the NotIn predicate on the "fop" field.
func FopNotIn(vs ...Fop) predicate.Payment {
	return predicate.Payment(sql.FieldNotIn(FieldFop, vs...))
}

// StatusEQ applies the EQ predicate on the "status" field.
func StatusEQ(v Status) predicate.Payment {
	return predicate.Payment(sql.FieldEQ(FieldStatus, v))
}

// StatusNEQ applies the NEQ predicate on the "status" field.
func StatusNEQ(v Status) predicate.Payment {
	return predicate.Payment(sql.FieldNEQ(FieldStatus, v))
}

// StatusIn applies the In predicate on the "status" field.
func StatusIn(vs ...Status) predicate.Payment {
	return predicate.Payment(sql.FieldIn(FieldStatus, vs...))
}

// StatusNotIn applies the NotIn predicate on the "status" field.
func StatusNotIn(vs ...Status) predicate.Payment {
	return predicate.Payment(sql.FieldNotIn(FieldStatus, vs...))
}

// IDChartOfAccountsEQ applies the EQ predicate on the "id_chart_of_accounts" field.
func IDChartOfAccountsEQ(v int) predicate.Payment {
	return predicate.Payment(sql.FieldEQ(FieldIDChartOfAccounts, v))
}

// IDChartOfAccountsNEQ applies the NEQ predicate on the "id_chart_of_accounts" field.
func IDChartOfAccountsNEQ(v int) predicate.Payment {
	return predicate.Payment(sql.FieldNEQ(FieldIDChartOfAccounts, v))
}

// IDChartOfAccountsIn applies the In predicate on the "id_chart_of_accounts" field.
func IDChartOfAccountsIn(vs ...int) predicate.Payment {
	return predicate.Payment(sql.FieldIn(FieldIDChartOfAccounts, vs...))
}

// IDChartOfAccountsNotIn applies the NotIn predicate on the "id_chart_of_accounts" field.
func IDChartOfAccountsNotIn(vs ...int) predicate.Payment {
	return predicate.Payment(sql.FieldNotIn(FieldIDChartOfAccounts, vs...))
}

// IDChartOfAccountsGT applies the GT predicate on the "id_chart_of_accounts" field.
func IDChartOfAccountsGT(v int) predicate.Payment {
	return predicate.Payment(sql.FieldGT(FieldIDChartOfAccounts, v))
}

// IDChartOfAccountsGTE applies the GTE predicate on the "id_chart_of_accounts" field.
func IDChartOfAccountsGTE(v int) predicate.Payment {
	return predicate.Payment(sql.FieldGTE(FieldIDChartOfAccounts, v))
}

// IDChartOfAccountsLT applies the LT predicate on the "id_chart_of_accounts" field.
func IDChartOfAccountsLT(v int) predicate.Payment {
	return predicate.Payment(sql.FieldLT(FieldIDChartOfAccounts, v))
}

// IDChartOfAccountsLTE applies the LTE predicate on the "id_chart_of_accounts" field.
func IDChartOfAccountsLTE(v int) predicate.Payment {
	return predicate.Payment(sql.FieldLTE(FieldIDChartOfAccounts, v))
}

// IDCurrencyEQ applies the EQ predicate on the "id_currency" field.
func IDCurrencyEQ(v int) predicate.Payment {
	return predicate.Payment(sql.FieldEQ(FieldIDCurrency, v))
}

// IDCurrencyNEQ applies the NEQ predicate on the "id_currency" field.
func IDCurrencyNEQ(v int) predicate.Payment {
	return predicate.Payment(sql.FieldNEQ(FieldIDCurrency, v))
}

// IDCurrencyIn applies the In predicate on the "id_currency" field.
func IDCurrencyIn(vs ...int) predicate.Payment {
	return predicate.Payment(sql.FieldIn(FieldIDCurrency, vs...))
}

// IDCurrencyNotIn applies the NotIn predicate on the "id_currency" field.
func IDCurrencyNotIn(vs ...int) predicate.Payment {
	return predicate.Payment(sql.FieldNotIn(FieldIDCurrency, vs...))
}

// IDCurrencyGT applies the GT predicate on the "id_currency" field.
func IDCurrencyGT(v int) predicate.Payment {
	return predicate.Payment(sql.FieldGT(FieldIDCurrency, v))
}

// IDCurrencyGTE applies the GTE predicate on the "id_currency" field.
func IDCurrencyGTE(v int) predicate.Payment {
	return predicate.Payment(sql.FieldGTE(FieldIDCurrency, v))
}

// IDCurrencyLT applies the LT predicate on the "id_currency" field.
func IDCurrencyLT(v int) predicate.Payment {
	return predicate.Payment(sql.FieldLT(FieldIDCurrency, v))
}

// IDCurrencyLTE applies the LTE predicate on the "id_currency" field.
func IDCurrencyLTE(v int) predicate.Payment {
	return predicate.Payment(sql.FieldLTE(FieldIDCurrency, v))
}

// TagEQ applies the EQ predicate on the "Tag" field.
func TagEQ(v Tag) predicate.Payment {
	return predicate.Payment(sql.FieldEQ(FieldTag, v))
}

// TagNEQ applies the NEQ predicate on the "Tag" field.
func TagNEQ(v Tag) predicate.Payment {
	return predicate.Payment(sql.FieldNEQ(FieldTag, v))
}

// TagIn applies the In predicate on the "Tag" field.
func TagIn(vs ...Tag) predicate.Payment {
	return predicate.Payment(sql.FieldIn(FieldTag, vs...))
}

// TagNotIn applies the NotIn predicate on the "Tag" field.
func TagNotIn(vs ...Tag) predicate.Payment {
	return predicate.Payment(sql.FieldNotIn(FieldTag, vs...))
}

// HasCustomer applies the HasEdge predicate on the "customer" edge.
func HasCustomer() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, CustomerTable, CustomerColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasCustomerWith applies the HasEdge predicate on the "customer" edge with a given conditions (other predicates).
func HasCustomerWith(preds ...predicate.Customer) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		step := newCustomerStep()
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasImputations applies the HasEdge predicate on the "imputations" edge.
func HasImputations() predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, ImputationsTable, ImputationsColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasImputationsWith applies the HasEdge predicate on the "imputations" edge with a given conditions (other predicates).
func HasImputationsWith(preds ...predicate.Imputation) predicate.Payment {
	return predicate.Payment(func(s *sql.Selector) {
		step := newImputationsStep()
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Payment) predicate.Payment {
	return predicate.Payment(sql.AndPredicates(predicates...))
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Payment) predicate.Payment {
	return predicate.Payment(sql.OrPredicates(predicates...))
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Payment) predicate.Payment {
	return predicate.Payment(sql.NotPredicates(p))
}
